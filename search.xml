<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[校园助手"小关"--第一周]]></title>
    <url>%2Fyinziang%2F2018%2F04%2F21%2FProject-CPSHelper-WeekOne%2F</url>
    <content type="text"><![CDATA[校园助手”小关”开发第一周工作记录 Day 1 18-04-16 项目拟题 项目拟题 模板 基于WEB的网络社团信息管理系统的设计与实现 基于ASP.NET技术的图书管理系统开发 拟题？ 基于 基于微信小程序的 基于Java Web的 基于WEB的 基于微服务架构的 校园智能助手的设计与实现 “阿关” 确定项目的核心模块 跑通SpringBoot-Mybatis的demo 简单使用 Java爬虫框架Jsoup的简单测试 能完成简单的页面获取和页面解析 1234567891011// 从华科图书馆爬取关键字为&quot;Java&quot;的搜索结果// 控制台输出50Java程序设计案例教程 / 秦军编著Java核心技术 / 白文荣主编Java开发实战经典 / 李兴华编著Absolute Java中文版 / (美) Walter Savitch, Kenrick Mock著Java课程设计 / 耿祥义, 张跃平编著Java程序开发案例课堂 / 刘春茂, 李琪编著Java语言程序设计 / 邵丽萍, 张驰编著... Day 2 18-04-17 尝试先确定需求文档和后端API，再去写代码的思路 学习MyBatis如何整合到SpringBoot，并使用MyBatis Generator(MBG)自动生成代码(实体类、Mapper文件和接口) 遇到很多问题，恰逢2.0的更新，无法复现学习代码 体会 不需要局限在Web，甚至不需要局限Java，需要做的只是后台的服务，具体来说就是提供Restful的API，然后前台想用什么就用什么 这个毕设我觉得可以学习之前的实训项目，先花相同的时间研究清楚需求，完成项目概要设计，然后留相同的时间来写代码，目标至少完成后台开发 MyBatis编写好SQL语句后，通过Dao或者Mapper接口，提供访问数据库的服务，这样的封装感觉很方便，社会社会！ SpringBoot提供了依赖继承，虽然可以简化配置，但如果starter配置过多反而不知道引用了什么，引用的是哪个版本，特别是报错时不知道哪里有问题，茫然脸！！！ 貌似SpringBoot的根错误在最后，优先解决最后的Bug提示 Day 3 18-04-18 很艰难的学习MBG 遇到问题 无权威教材 视频貌似 主要还是SpringBoot的依赖链看不见，视频教材中的依赖版本很多，根本无从下手 回顾整体设计 默认用户群体是本科以上的学生，然后管理具有一定的计算机知识，能通过 很多功能的实现依赖于爬虫 成绩 图书查询 课表？ Web这边的强项应该是前后台C/S 开放后台，特定权限可以操作(增删查改) 前台登陆查看或者直接记录用户地址来推送 继续分析需求、场景 自习室预定 按照位置来预约比较难所以放弃 维护可自习教室列表 自习室(校区[东、西]，楼栋号，区域，教室号，可自习人数，已在自习人数) 每天晚上九点(?)自动归零 申请仔细 先提供实时各教学楼自习情况(已自习人数/可自习人数) 查询某栋楼，按区域返回自习情况 查询各教室自习情况 申请自习开始时间 离开自习时间打卡，由打卡机返回 可查询本班同学申请自习信息 有些问题值得商榷 申请座位不限 自习开始时间也应该绑定打卡机？ 快递互助 快递领取信息向好友开放 可登记快递领取信息 可查询好友登记的快递领取信息 帮忙领取后实名标记已完成 旧物分享 免费或交换 类似于BBS留言留贴 上传旧物信息，在其下交流分享信息 Day 4 18-04-19 放飞自我，休息 Day 5 18-04-20 系统的从头开始毕设项目 确定项目目标–2018年6月21日之前完成后台的开发 完成项目启动和项目计划 制订时间计划12345678910111213ganttdateFormat YYYY-MM-DDtitle 毕设突击计划section 第1阶段项目启动: 2018-04-17, 1dsection 第2阶段项目计划: 2018-04-18, 2dsection 第3阶段需求分析: 2018-04-20, 3dsection 第4阶段系统设计: 2018-04-23, 4dsection 第5阶段系统编码实现及测试:2018-04-27, 14d 开始按照计划完成需求分析 4.20完成相关文献查找工作，回顾实训项目文档 4.21完成需求文档的”具体需求–系统用例”板块 4.22完成需求文档的”数据字典”和其他版块，结束、 Day 6 18-04-21 基本完成需求文档的”具体需求–系统用例”板块 Day 7 18-04-22]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里云CentOS实践]]></title>
    <url>%2Fyinziang%2F2018%2F04%2F14%2FPractice_tryAliCloud%2F</url>
    <content type="text"><![CDATA[在阿里云CentOS 7服务器上配置并部署JavaSSM框架项目 环境配置 Docker 安装 1# yum -y install docker 启动和关闭 12# sudo service docker start# sudo service docker stop 镜像加速 增加网易蜂巢的镜像1234567# cd /etc/docker# vim daemon.json增加成&#123; &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;]&#125; JDK 下载JDK cd到”/usr/local/tools/“ – Jdk路径为/usr/local/tools/jdk1.8 会出现直接wget拉下来的不是jdk文件而是简单的页面 怀疑是因为要在下载页面勾选同意Oracle有关规则才能下载 解决办法 本地下载然后同步到服务器 获取可用的下载链接然后在服务器上wget12以下是可行链接，很明显带上了参数# wget http://download.oracle.com/otn-pub/java/jdk/8u161-b12/2f38c3b165be4555a1fa6e98c45e0808/jdk-8u161-linux-x64.tar.gz?AuthParam=1523515932_e42f8ed4698c8cfb731bc04c03581fbc 给所有用户配置Java环境 用root用户登录 1234567# vim /etc/profile按下insert，然后移动到最后一行，添加如下#configuration java development enviroumentexport JAVA_HOME=/usr/local/tools/jdk1.8export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 给当前用户配置Java环境 1234567# vim ~/.bash_profile按下insert，然后移动到最后一行，添加如下#configuration java development enviroumentexport JAVA_HOME=/usr/local/tools/jdk1.8export PATH=$JAVA_HOME/bin:$PATH export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar 退出重新登录，查看Java版本信息确定安装效果 1# java -version 配置Tomcat 前往Tomcat的官网获取下载链接 wget拉下来，然后解压 遇到的天坑 – 阿里云安全组设置 需要在阿里云控制台设置安全端口(入\出) 加入”8080/8080”端口 授权对象改为”0.0.0.0/0” 防火墙修改，增加端口 解决CentOS（6和7版本），/etc/sysconfig/下没有iptables的问题 CentOS 7 停止firewalld 安装iptables-services 在引导时启用iptables服务 启动iptables服务 保存防火墙规则 其他管理 1systemctl [stop|start|restart] iptables 修改iptables防火墙文件，增加端口 cd到系统配置 1# cd /etc/sysconfig/ 编辑iptables 123# vim iptables增加8080端口(复制22端口整行，修改端口号为8080即可) 重启iptables curl命令测试端口是否开放 1# curl 127.0.0.1:8080 数据库 望周知 CentOS 7开始使用MySQL的分支MariaDB 基本上可以认为一样 安装和配置 CentOS 7.0 使用 yum 安装 MariaDB 与 MariaDB 的简单配置 使用yum下载安装 然后初始化账号密码 赋予账号权限和访问IP限制 字符编码 服务器执行sql文件 确定文件位置，如”/root/xxshop.mysql” 进入数据库，创建database，设定格式 12345# mysql -uroot -pmysql123&gt;create database xxshop;&gt;use xxshop;&gt;set names utf8;&gt;source /root/xxshop.sql 实战xxshop项目在云服务器上跑起来 按以上配置好环境 本地上传文件到服务器 使用SSH服务的scp命令 1234# scp a.txt root@127.0.0.1:/home/neo/test/b.txt将当前目录下的a.txt文件上传到ssh服务器上test文件夹并改名为b.txt，其中SSH服务器网址为127.0.0.1，用户名root# scp -r xxshop.war root@119.23.10.167:上传到当前用户目录，如该IP中用户为root，&quot;# cd /root/&quot;即到上传目录 上传数据库sql文件，然后执行 上传war包到Tomcat的webapps路径下 Tomcat修改配置文件 修改服务器配置文件123&lt;!-- Host标签内加上 --&gt;&lt;Host&gt;&lt;Context path=&quot;/&quot; docBase=&quot;xxshop&quot; unpackWARs=&quot;true&quot; debug=&quot;0&quot; privileged=&quot;true&quot; reloadable=&quot;true&quot; /&gt;&lt;/Host&gt;&lt;!--这里使用的是相对路径，docBase的值是我们放到webapps文件夹下的war名称--&gt; 然后根据云服务器IP在本地浏览器访问 http://119.23.10.167:8080/xxshop/ 一些小问题 CentOS下SSH登录local警告 设置了”默认地区_语言.字符集”为 “en_US.UTF-8”，但是在系统中没有定义这个问题1-bash: warning: setlocale: LC_CTYPE: cannot change locale (en_US.UTF-8): No such file or directory 输入以下命令，然后重启 12345678# tee /etc/environment &lt;&lt;- &apos;EOF&apos; LANG=en_US.utf-8 LC_ALL= EOF# source /etc/environment/* 生成 en_US.UTF-8 locale文件 CentOS没有locale-gen命令*/# localedef -v -c -i en_US -f UTF-8 en_US.UTF-8]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双色球爬虫项目]]></title>
    <url>%2Fyinziang%2F2018%2F04%2F11%2FPractice_spiderOnDoubleChromosphere%2F</url>
    <content type="text"><![CDATA[Python爬虫的小项目 需求 爬取最近一期的双色球号码 按固定格式推送到用户 “第2018040期 红 02 16 18 19 27 30 蓝 14” 想法 利用爬虫框架爬取 库 – requests、BeautifulSoup 调用短信发送框架快速发送 twilio短信发送平台 实际操作 爬取 直接爬取福彩官网”http://www.cwl.gov.cn“ 利用搜索引擎接口，搜索关键词然后获取结果 搜索接口 百度 – http://www.baidu.com/s?wd=keyword 360 – http://www.so.com/s?q=keyword 代码框架123456789101112import requestskeyword = "福彩双色球"try: kv = &#123;'wd' : keyword&#125; r = requests.get("http://www.baidu.com/s", params=kv) print(r.request.url) r.raise_for_status() r.encoding = r.apparent_encoding # TODO print(r.text[-500:])except: print("爬取失败") 信息提取 BeautifulSoup库 查找标签然后固定提取目标信息 短信发送 Twilio官网 注册账号 获取账户SID和AUTH(认证)标志 建立第一个项目并获取免费手机号 代码框架1234567891011121314# 使用Twilio的免费手机号发送短信def send_sms(msg, my_number): # 从官网获得以下信息 account_sid = &apos;xxxx&apos; auth_token = &apos;xxxx&apos; twilio_number = &apos;xxxx&apos; # 带世界级区号 client = Client(account_sid, auth_token) try: client.messages.create(to=my_number, from_=twilio_number, body=msg) print(&apos;短信已经发送！&apos;) except ConnectionError as e: print(&apos;发送失败，请检查你的账号是否有效或网络是否良好！&apos;) return e 遇到问题Bug BeautifulSoup库的API不熟 电话号码格式 TwilioRestException: Unable to create record: The &#39;To&#39; number 1817127xxxx is not a valid phone number. 报错如上 加区号 “1817127xxxx” –&gt; “+861817127xxxx” 反思 不太熟悉BeautifulSoup库API，用的查找是硬代码 部署及定期(如周二、周四、周日)推送功能还没有实现]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown学习]]></title>
    <url>%2Fyinziang%2F2018%2F03%2F26%2FTools-MarkDownNote%2F</url>
    <content type="text"><![CDATA[一些常用的MarkDown知识 目录 标题-ATX形式 表格 代码 标题 分割线 列表 引用 粗体和斜体 链接和图片 附录 to-do list 数学公式 各种图 标题-ATX形式标题6标题5标题4标题3标题2标题1表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 左右对齐 header 1 header 2 header 3 r r r r r r 代码123public static void main(String args[]) &#123; System.out.println("Hello World!");&#125; 分割线 列表无序列表 Candy. chen yin Gum. 星 明 天 地 有序列表 Red RedGreen RedRed Green Blue 引用 Life is short, I use Python. This is a blockquote . 粗体和斜体 Some of these words are emphasized.Some of these words are emphasized also.Use two asterisks for strong emphasis.Or, if you prefer, use two underscores instead. 链接&amp;图片链接 This is an example link. I get 10 times more traffic from [Google][1] than from[Yahoo][2] or [MSN][3].[1]: http://google.com/ “Google”[2]: http://search.yahoo.com/ “Yahoo Search”[3]: http://search.msn.com/ “MSN Search” 图片 Specialto-do list 已完成项目1 已完成事项1 已完成事项2 已完成项目1 已完成事项1 已完成事项2 数学公式1E = mc^2 各种图有道教学链接]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法&OJ--其他--LRU算法实现]]></title>
    <url>%2Fyinziang%2F2018%2F03%2F19%2FAlgo-OJ-Others-LRUImpl%2F</url>
    <content type="text"><![CDATA[缓存淘汰算法–LRU算法的实现 LRU Least recently used, 最近最少使用 根据数据的历史访问记录来进行淘汰数据 其核心思想是”如果数据最近被访问过，那么将来被访问的几率也更高” 实现保存缓存数据 循环数组实现的队列 数字在小范围的遍历很快 队列实现LRU 链表 链表的插入和删除时间复杂度都为O(1)–&gt;用链表不用数组 具体过程 新数据插入到链表头部 每当缓存命中(即缓存数据被访问)，则将数据移到链表头部 当链表满的时候，将链表尾部的数据丢弃 分析 【命中率】当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重 【复杂度】实现简单 【代价】 命中时需要遍历链表，找到命中的数据块索引，然后需要将数据移到头部 LinkedHashMap 利用hashmap的特点–命中很快(是否在缓存中) 双向链表的队列实现LRU123456789101112131415161718192021222324252627282930313233343536373839import java.util.*;class LRULinkedHashMap&lt;K,V&gt; extends LinkedHashMap&lt;K,V&gt; &#123; //定义缓存的容量--LinkedHashMap默认超过最大容量自动扩容，不存在remove eldest的问题 private int capacity; private static final long serialVersionUID = 1L; //带参数的构造器 LRULinkedHashMap(int capacity)&#123; //调用LinkedHashMap的构造器，传入以下参数 super(16,0.75f,true); //传入指定的缓存最大容量 this.capacity=capacity; &#125; //实现LRU的关键方法，如果map里面的元素个数大于了缓存最大容量，则删除链表的顶端元素 @Override public boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest)&#123; // 每次增加都会调用该方法看是否需要remove eldest System.out.println(eldest.getKey() + "=" + eldest.getValue()); return size()&gt;capacity; /*return false;*/ &#125;&#125;//测试类public class Main&#123; public static void main(String[] args) throws Exception&#123; //指定缓存最大容量为4 Map&lt;Integer,Integer&gt; map=new LRULinkedHashMap&lt;&gt;(4); map.put(9,3); map.put(7,4); map.put(5,9); map.put(3,4); //map.put(6,6); //总共put了5个元素，超过了指定的缓存最大容量 //遍历结果 for(Iterator&lt;Map.Entry&lt;Integer,Integer&gt;&gt; it = map.entrySet().iterator(); it.hasNext();)&#123; System.out.println(it.next().getKey()); &#125; &#125;&#125; 参考 缓存淘汰算法–LRU算法(java代码实现) 理解LinkedHashMap实现LRU缓存 Map 综述（二）：彻头彻尾理解 LinkedHashMap]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ab - Apache HTTP server benchmarking tool]]></title>
    <url>%2Fyinziang%2F2018%2F03%2F13%2FTools-ApacheAB%2F</url>
    <content type="text"><![CDATA[利用Apache ab对网站的性能测试 ab每次只能测试一个URL，适合做重复压力测试，支持POST方式 压力测试 定义 关键指标 服务器有关的最重要两个指标，其主要反映的是QPS和RT 每秒请求数(即服务器的吞吐量) – Requests per second 用户平均请求等待时间(请求延迟) – Time per request 服务器压力测试的若干指标 吞吐率 服务器处理并发请求的能力 计算公式为: 总请求数 / 完成所有请求花费的总时间 需要注意的是，吞吐率不能脱离并发数(并发用户数)而单独存在，在不同的并发数情况下，即使总请求数一样，并发数也可能会不一样 并发连接数 并发连接数指某个时刻服务器处理的连接数 此概念的某个时刻是一个特定的时间点 并发用户数的概念和并发连接数密切相关，并发连接数一定大于等于并发用户数(一个用户可能同时发送多个并发请求) 用户请求平均等待时间 处理完所有请求花费总时间 / 并发用户数 服务器平均请求完成时间 处理完所有请求所花费时间/总请求数 吞吐率的倒数，也和并发数密切相关，不能脱离并发数来描述服务器平均请求等待时间 评价 标准可参考国外的3/5/10原则： 在3秒钟之内，页面给予用户响应并有所显示，可认为是“很不错的” 在3~5秒钟内，页面给予用户响应并有所显示，可认为是“好的” 在5~10秒钟内，页面给予用户响应并有所显示，可认为是“勉强接受的” 超过10秒就让人有点不耐烦了，用户很可能不会继续等待下去 大佬指导 可适当因人而异 遇到问题 ab一个小bug: 本地访问URL不能用localhost invalid URL Usage: ab [options] [http[s]://]hostname[:port]/path```12* 解决办法 * 改用```http://127.0.0.1:端口号/ 默认并发数不足 默认原始值为256 Too many open files (24)```1* 解决办法 ```ulimit -n 所需最大并发 12345678910111213141516171819202122232425$ ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited file size (blocks, -f) unlimited max locked memory (kbytes, -l) unlimited max memory size (kbytes, -m) unlimited open files (-n) 256 pipe size (512 bytes, -p) 1 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 1418 virtual memory (kbytes, -v) unlimited$ ulimit -n 2000$ ulimit -a core file size (blocks, -c) 0 data seg size (kbytes, -d) unlimited file size (blocks, -f) unlimited max locked memory (kbytes, -l) unlimited max memory size (kbytes, -m) unlimited open files (-n) 2000 pipe size (512 bytes, -p) 1 stack size (kbytes, -s) 8192 cpu time (seconds, -t) unlimited max user processes (-u) 1418 virtual memory (kbytes, -v) unlimited 貌似这个最大并发为2w 无连接，未打开网站 reset by peer (54)```12* 解决办法 * 后台服务器Run起来 $ ab -n 10000 -c 1000 http://127.0.0.1:8080/ Server Software:Server Hostname: 127.0.0.1Server Port: 8080 Document Path: /Document Length: 51188 bytes Concurrency Level: 1000Time taken for tests: 79.990 secondsComplete requests: 10000Failed requests: 0Total transferred: 514000000 bytesHTML transferred: 511880000 bytesRequests per second: 125.02 [#/sec] (mean)Time per request: 7999.024 [ms] (mean)Time per request: 7.999 [ms] (mean, across all concurrent requests)Transfer rate: 6275.18 [Kbytes/sec] received Connection Times (ms) min mean[+/-sd] median maxConnect: 0 3 8.9 0 40Processing: 361 7700 1534.6 7740 14918Waiting: 360 7699 1534.6 7738 14916Total: 396 7703 1529.1 7740 14946 Percentage of the requests served within a certain time (ms) 50% 7740 66% 8174 75% 8500 80% 8709 90% 9313 95% 9832 98% 10509 99% 11081 100% 14946 (longest request)``` 参考网站 Apache ab性能测试结果分析 运行ab测试时socket: Too many open files (24) 的解决办法]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法&OJ--其他--动态规划]]></title>
    <url>%2Fyinziang%2F2018%2F03%2F08%2FAlgo-OJ-Others-4%2F</url>
    <content type="text"><![CDATA[动态规划小结 常见题 归类 （长路漫漫，未完待续ing） 动态规划的常见类型分为如下几种： 矩阵型 序列型 双序列型 划分型 区间型 背包型 状态压缩型 树型 其中，在技术面试中经常出现的是矩阵型，序列型和双序列型。划分型，区间型和背包型偶尔出现。状态压缩和树型基本不会出现（一般在算法竞赛中才会出现）。每种类型都有着自己的题目特点和状态的表示方法。将所做过的动态规划问题按照这些类别进行归类，分析状态的表示方法和状态转移方程的构造方法在每种类型中的近似之处，会让你更快的学会动态规划。 总结与思考 DP问题注意 递推式 初值 空间优化 多练习，多思考–LeetCode 85，91，97，120，131，132，139，140，152 一、矩阵型以矩阵型动态规划为例，一般题目会给你一个矩阵，告诉你有一个小人在上面走动，每次只能向右和向下走，然后问你比如有多少种方案从左上走到右下。这种类型状态表示的特点一般是使用坐标作为状态，如f[i][j]表示走到(i,j)这个位置的时候，一共有多少种方案。状态的转移则是考虑是从哪儿走到(i,j)这个坐标的。 例1.1 机器人走路径 A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).How many possible unique paths are there?Above is a 3 x 7 grid. How many possible unique paths are there?Note: m and n will be at most 100. 例1.2棋盘路径最小和 Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.Note: You can only move either down or right at any point in time. 二、序列型序列型的动态规划，一般是告诉你一个序列。 例2.1 Best Time to Buy and Sell Stock 一 Say you have an array for which the i-th elements is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. 例2.2 Best Time to Buy and Sell Stock 二 Say you have an array for which the i-th element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 例2.3 Best Time to Buy and Sell Stock 三 Say you have an array for which the i-th element is the price of a given stock on day i.Design an algorithm to find the maximum profit. You may complete at most two transactions.Note: You may not engage in multiple transactions at the same time (ie, you must sell the sock before you buy again). 例2.5 连续子数组的最大和 在一维模式识别中,常常需要计算连续子向量的最大和,当向量全为正数的时候,问题很好解决。但是,如果向量中包含负数,是否应该包含某个负数,并期望旁边的正数会弥补它呢？例如:{6,-3,-2,7,-15,1,2,2}的连续子向量的最大和为8(从第0个到第3个)。(子向量的长度至少是1) 12345678910int FindGreatestSumOfSubArray(vector&lt;int&gt; array) &#123; if(array.empty()) return 0; int sum = array[0], tempsum = array[0]; //注意初始值 不能设为0 防止只有负数 for(int i = 1; i &lt; array.size(); i++) //从1开始 因为0的情况在初始化时完成了 &#123; tempsum = (tempsum &lt; 0) ? array[i] : tempsum + array[i]; sum = (tempsum &gt; sum) ? tempsum : sum; &#125; return sum; &#125; 例2.6 数组其他元素的乘积 给定一个整数数组，编写一个函数来替换每个元素，使用除了该元素之外的所有元素的乘积来替换 1234567891011121314151617181920public void replaceWithProducts(int[] a, int n) &#123; if(a==null || a.length==0 || a.length!=n) &#123; return; &#125; // 双向DP，双向累计不包含当前index的乘积 int[] d1 = new int[n]; // 正向乘积累计 int[] d2 = new int[n]; // 逆向乘积累计 d1[0] = 1; d2[n-1] = 1; for(int i=1; i&lt;n; i++) &#123; d1[i] = a[i-1] * d1[i-1]; d2[n-i-1] = a[n-i] * d2[n-i]; &#125; a[0] = d2[0]; a[n-1] = d1[n-1]; for(int i=1; i&lt;n; i++) &#123; a[i] = d1[i] * d2[i]; &#125;&#125; 三、双序列型双序列的动态规划一般是告诉你两个字符串或者两个序列 例3.1 最长公共子串 对于两个字符串，请设计一个时间复杂度为O(m*n)的算法(这里的m和n为两串的长度)，求出两串的最长公共子串的长度。这里的最长公共子串的定义为两个序列U1,U2,..Un和V1,V2,…Vn，其中Ui + 1 == Ui+1,Vi + 1 == Vi+1，同时Ui == Vi。给定两个字符串A和B，同时给定两串的长度n和m。测试样例：”1AB2345CD”,9,”12345EF”,7返回：4 例3.2 编辑距离 给定两个字符串S和T，求把S变成T所需要的最少操作次数。操作包括：在任意位置增加一个字符、减少一个字符以及修改任意一个字符(LeetCode 72) 换个角度思考问题，变为字符串对齐问题 S=”ABCF” T=”DBFG” S A B C F - T D B - F G 打分 对应位置相同不扣分 两个特殊字符”-“不会对应 S位置”-“代表增加字符 T位置”-“代表删除字符 使扣分最小 状态方程 dp[i][j]表示S的前i个位置和T的前j个位置对齐的最少得分 dp[i][j]=min(dp[i-1][j-1]+same(i,j), dp[i-1][j]+1, dp[i][j-1]+1) dp[i-1][j-1]+same(i,j) 对应S第i个字符和T第j个字符对齐 dp[i-1][j]+1 对应S第i个字符和”-“对齐，即删掉S中第i个字符 dp[i][j-1]+1 对应T第j个字符和”-“对齐，即在S中增加该字符 初值 dp[0][j]=j, dp[i][0]=i (i&gt;=0, j&gt;=0) 时空复杂度 空间优化–省掉一维 对每个i，正向循环j(注意保存dp[i-1][j-1]，因为j-1已经是新值) 1234567891011121314151617181920212223public int minDistance(String word1, String word2) &#123; char[] S = word1.toCharArray(); char[] T = word2.toCharArray(); int SLength = S.length; int TLength = T.length; int[][] dp = new int[SLength+1][TLength+1]; for(int i=0; i&lt;=SLength; i++) &#123; for(int j=0; j&lt;=TLength; j++) &#123; if(i == 0) &#123; dp[i][j] = j; &#125; else if(j == 0) &#123; dp[i][j] = i; &#125; else &#123; dp[i][j] = min(dp[i-1][j-1] + ((S[i-1]==T[j-1])?0:1), min(dp[i][j-1] + 1, dp[i-1][j] + 1) ); &#125; &#125; &#125; return dp[SLength][TLength];&#125; 四.区间型动态规划例 4.1 LintCode-363.接雨水 系列一 Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. 注意：此时竖边是有宽度的。 此题本质：某一bar的接水量=min(左边bar最大高度，右边bar最大高度)-bar高 最直接的做法 双数组，一个储存左边bar最大高度，一个储存右边bar最大高度 有点绕的最优解 两个记录最大高度的数组，自最大值出现后就不会被调用了(因为取得是min值) 采用对撞型指针，每次让高度较小的指针移动即可 该指针处接水量即为该方向最大值减去该处bar高 循环直至两指针相遇于最高处 123456789101112131415161718192021222324252627public int trapRainWater(int[] heights) &#123; // 双指针问题 if(heights==null || heights.length&lt;2) &#123; return 0; &#125; int water = 0; int left = 0; int right = heights.length - 1; int lMax = 0; int rMax = 0; while(left &lt; right) &#123; lMax = max(lMax, heights[left]); rMax = max(rMax, heights[right]); if(lMax &lt; rMax) &#123; water += lMax - heights[left]; left++; &#125; else &#123; water += rMax - heights[right]; right--; &#125; &#125; return water;&#125; public int max(int a, int b) &#123; return a&gt;b?a:b;&#125; 五.others5.1 爬台阶 You are climbing a stair case. It takes n steps to reach to the top.Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 5.2 矩形覆盖 我们可以用21的小矩形横着或者竖着去覆盖更大的矩形。请问用n个21的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？ dp[0]=0 dp[1]=1 dp[2]=2 dp[i]=dp[i-1]+dp[i-2] 此处可横着可竖着，所以递推式右边系两项 123456public int RectCover(int target) &#123; if(target == 0) &#123; return 0;&#125; if(target == 1) &#123; return 1;&#125; if(target == 2) &#123; return 2;&#125; return RectCover(target-1) + RectCover(target-2);&#125; 无.似是而非无.1 数组单调和 现定义数组单调和为所有元素i的f(i)值之和。这里的f(i)函数定义为元素i左边(不包括其自身)小于等于它的数字之和。请设计一个高效算法，计算数组的单调和。给定一个数组A同时给定数组的大小n，请返回数组的单调和。保证数组大小小于等于500，同时保证单调和不会超过int范围。测试样例：[1,3,5,2,4,6],6返回：27]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法&OJ--其他--OnlineJudge输入输出特辑]]></title>
    <url>%2Fyinziang%2F2018%2F03%2F05%2FAlgo-OJ-Others-3%2F</url>
    <content type="text"><![CDATA[总结Java的OJ输入可行处理 OJ入门级问题 Java的输入输出 一般使用Scanner对象来读取控制台的输入 常见的处理： Scanner对象in in.hasNext()时读取in.next()或in.nextInt()或in.nextLine() 自己IDE测试读取输入，最后需手动输入文件结束符EOF 输入完数据集后回车一行 然后Mac–输入Control+d Windows系统下键入control+z，同时键入ctrl+z 例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 输入描述：输入包括一行,一行中有4个正整数x1, k1, x2, k2(1 ≤ x1,x2 ≤ 10^9, 1 ≤ k1,k2 ≤ 50),以空格分割 * 如：1010 3 101010 2 */import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); String[] s = new String[4]; int index = 0; while(in.hasNext()) &#123; s[index++] = in.next(); &#125; // ······ &#125; // ······&#125;/** * 输入描述：输入中有多组测试数据，每组测试数据为一个整数A(1 ≤ A ≤ 5000). * 如： &gt; 5 &gt; 3 */import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner in = new Scanner(System.in); ArrayList&lt;Integer&gt; nums = new ArrayList&lt;&gt;(); while(in.hasNext()) &#123; nums.add(in.nextInt()); &#125; // ······ &#125;&#125;/** * 输入描述：每组输入数据分为三行,第一行有两个数字n,m(0 ≤ n,m ≤ 10000)，分别表示集合A和集合B的元素个数。后两行分别表示集合A和集合B。每个元素为不超过int范围的整数,每个元素之间有个空格隔开。 * 如： &gt; 3 3 &gt; 1 3 5 &gt; 2 4 6 */import java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; int count = 0; Scanner in = new Scanner(System.in); ArrayList&lt;Integer&gt; reads = new ArrayList&lt;&gt;(); while(in.hasNext()) &#123; reads.add(in.nextInt()); count++; &#125; int[] a = new int[reads.size()-2]; for(int i=0; i&lt;a.length; i++) &#123; a[i] = reads.get(i+2); &#125; // ······ &#125;&#125; 一些入门级问题 什么是“在线编程”？ 在线编程，是利用“Online Judge”系统实时判断编程结果的一种训练/考试方式。“Online Judge”简称OJ，它有一个web界面与其用户交流，还有一个后台的编译系统，编译、运行用户提交的程序代码，并判断代码的正误。 “在线编程”有哪些限制？ 你的程序（我们称之为“作业”）提交给 OJ系统后，OJ后台的编译器会编译该作业。如果通过，则运行这个作业。 限制1： 你的“作业”代码中，main()函数的返回值一定得是0 (即： return 0;) 限制2： 你的“作业”只允许从控制台读取数据（用C语言的scanf()、getchar()等；C++的cin） 限制3： 你的“作业”值允许输出到控制台（用C语言的printf()等，C++的cout); 限制4： 你的“作业”不允许读写文件系统（不能使用C语言的fprintf()等，不能使用C++的fstream等）； “在线编程（OJ）”系统如何判断提交的程序是否正确？ 判断1： 编译不能有错误 判断2： OJ系统运行你的程序，你的程序的返回值必须是 0，如果不是0，说明程序运行时出现错误 判断3： 在OJ出题的人，会预先提供一些输入数据和输出结果；你的“作业”在运行时会被“喂”进上述输入数据，然后你的“作业”会输出信息，这些信息与上述“输出结果”【逐个字符】对比。如果对比完全一致，则判定你的“作业”正确。 如何检查你自己的程序是否正确？ 在题目中，会给你一套对应的“输入样例”和“输出样例”。你在运行自己的作业时，将“输入样例”喂给你的程序（用键盘，别用勺子！）得到的输出结果与“输出样例”一个字符都不差（空格、换行都算在内）完全相同，那么你的程序的输出格式就是正确的。 例子 OJ中的一个题目：编写程序，计算输入的两个整数之和。 输入： 空格分隔的两个整数； 输出： 整数之和 出题者给的输入和输出 （这就是本课程中的“测试例”。测试例的具体内容，只有出题者才能看到） 输入样例：-3 1 输出样例：-2 你的程序如果输出以下信息，都是错的 错误1：输出结果前有空格 &gt; -2 错误2：输出结果后有空格 &gt;-2_ 错误3：输出结果后有回车换行 &gt; -2 &gt; 错误4：有额外提示信息 &gt;output: -2 错误5：输出的不是整数 &gt;-2.000 有时出题者会给出一些极端的测试例，用于检测你的程序是否足够健壮： 输入：-999999999999999999999999999 1 输出：&gt;?#$#%#@!%^]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法&OJ--其他--接水装水问题]]></title>
    <url>%2Fyinziang%2F2018%2F03%2F04%2FAlgo-OJ-Others-2%2F</url>
    <content type="text"><![CDATA[总结LintCode上两类看起来类似的问题 装水问题 接水问题 LintCode-383.装最多水的容器 给定 n 个非负整数 a1, a2, …, an, 每个数代表了坐标中的一个点 (i, ai)。画 n 条垂直线，使得 i 垂直线的两个端点分别为(i, ai)和(i, 0)。找到两条线，使得其与 x 轴共同构成一个容器，以容纳最多水。注意：容器不可倾斜。 暴力遍历 每条线和之前所有线计算 记录最大值 时间复杂度：O(n^2) 示例解法 两个指针分别从数组两端开始向中间遍历(分别找到高度不为零的竖边) 每次计算面积，并记录最大值 将较低高度的指针移动一位 遍历整个数组 时间复杂度：O(n) 就示例解法me的思考 从两端逼近，容器X轴边长单调减小，要使面积增大的话，必须增大宽，所以保留长的竖边 1234567891011121314151617181920212223// 示例AC代码public class Solution &#123; // for any i, the maxium area will be the farthest j that has a[j] &gt; a[i]; public int maxArea(int[] height) &#123; if(height == null || height.length &lt; 2) &#123; return 0; &#125; int max = 0; int left = 0; int right = height.length -1; while(left &lt; right) &#123; max = Math.max( max, (right - left) * Math.min(height[left],height[right])); if(height[left] &lt; height[right])&#123; left++; &#125; else &#123; right--; &#125; &#125; return max; &#125;&#125; LintCode-363.接雨水 系列一 Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. 注意：此时竖边是有宽度的。 此题本质：某一bar的接水量=min(左边bar最大高度，右边bar最大高度)-bar高 最直接的做法 双数组，一个储存左边bar最大高度，一个储存右边bar最大高度 有点绕的最优解 两个记录最大高度的数组，自最大值出现后就不会被调用了(因为取得是min值) 采用对撞型指针，每次让高度较小的指针移动即可 该指针处接水量即为该方向最大值减去该处bar高 循环直至两指针相遇于最高处 123456789101112131415161718192021222324252627public int trapRainWater(int[] heights) &#123; // 双指针问题 if(heights==null || heights.length&lt;2) &#123; return 0; &#125; int water = 0; int left = 0; int right = heights.length - 1; int lMax = 0; int rMax = 0; while(left &lt; right) &#123; lMax = max(lMax, heights[left]); rMax = max(rMax, heights[right]); if(lMax &lt; rMax) &#123; water += lMax - heights[left]; left++; &#125; else &#123; water += rMax - heights[right]; right--; &#125; &#125; return water;&#125; public int max(int a, int b) &#123; return a&gt;b?a:b;&#125; LintCode-364.接雨水 系列二 Given n x m non-negative integers representing an elevation map 2d where the area of each cell is 1 x 1, compute how much water it is able to trap after raining. emmm 此题感觉难度过大。暂不研究]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法&OJ--其他--背包问题]]></title>
    <url>%2Fyinziang%2F2018%2F03%2F03%2FAlgo-OJ-Others-1%2F</url>
    <content type="text"><![CDATA[总结两类 01背包问题 部分背包问题 01背包问题 往背包中装物品。物品有重量和价值属性。每个物品只有一件且不能分割，在不超过背包容量的同时，如何选取物品，使得背包所装的价值最大（背包可以装不满） 经典的DP动态规划问题 具有最优子结构(在此略去证明过程) 递归求解 每个物品都可以选择放入或不放入，n个物品就需要做n次选择 设f[i][w]表示前i件物品恰放入一个容量为w的背包可获得的最大价值 如果放入第i件物品，则f[i][w] = f[i-1][w-w[i]] + v[i] 如果不放入第i件，则f[i][w] = f[i-1][w] 显然有f[i][w] = max(f[i-1][w-w[i]]+v[i], f[i-1][w]) 结合以下实例来理解：往容量的50的包里装(W,A)分别为以下的物品(10,60)、(20,100)、(30,120) 优化空间 采用一维数组来记录每次的判断结果 最终能完全利用该背包的必然是最大价值(即数组最后一个元素) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// LintCode-125.背包问题 二/** * 问题描述：给出n个物品的体积A[i]和其价值V[i]，将他们装入一个大小为m的背包，最多能装入的总价值有多大？ * @param m: An integer m denotes the size of a backpack * @param A: Given n items with size A[i] * @param V: Given n items with value V[i] * @return: The maximum value */public int backPackII(int m, int[] A, int[] V) &#123; // 边界情况 if(A==null || V==null || A.length!=V.length || A.length==0 || m&lt;=0) &#123; return -1; &#125; int[] dp = new int[m+1]; int max = 0; for(int i=0; i&lt;A.length; i++) &#123; for(int j=m; j&gt;=A[i]; j--) &#123; if(dp[j-A[i]]+V[i] &gt; dp[j]) &#123; dp[j] = dp[j-A[i]]+V[i]; &#125; if(dp[j] &gt; max) &#123; max = dp[j]; &#125; &#125; &#125; return max;&#125;// 变式// LintCode-92.背包问题/** * 问题描述：在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]。(不可切割物品) * @param m: An integer m denotes the size of a backpack * @param A: Given n items with size A[i] * @return: The maximum size */public int backPack(int m, int[] A) &#123; if(A==null || A.length==0 || m&lt;=0) return -1; int n = A.length; int[] dp = new int[m+1]; int max = -1; for(int i=0 ;i&lt;n; i++) &#123; for(int j=m; j&gt;=A[i]; j--) &#123; if(dp[j-A[i]] + A[i] &gt; dp[j]) &#123; dp[j] = dp[j-A[i]] + A[i]; if(dp[j] &gt; max) &#123; max = dp[j]; &#125; &#125; &#125; &#125; return max;&#125; 部分背包问题 问题描述 思路 计算出平均价值重量value/weight 按照value/weight从高到低填充背包 最后剩下的装不下的空间，按照该均值乘以剩余容量 物品 重量 价值 单位重量的价值量 A 10 60 6 B 20 100 5 C 30 120 4 例如有如下问题 背包容量是50，求背包可以装三种物品的最大价值(物品可以被拆分) 由于可以拆分，考虑的是单位重量的价值量 可以轻易求得最优价值是：60+100+4*(50-30)=240 完全背包问题 待整理ing 参考资料 动态规划之详细分析0-1背包问题 0-1背包问题入门 0-1背包问题]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学JUnit]]></title>
    <url>%2Fyinziang%2F2018%2F02%2F28%2FTools-JUnit%2F</url>
    <content type="text"><![CDATA[以JUnit为例，学习单元测试相关知识 JUnit什么是单元测试 写了个类，要给别人用，会不会有bug？怎么办？测试一下。用main方法测试好不好？不好！ 不能一起运行！ 大多数情况下需要人为的观察输出确定是否正确 为什么要进行单元测试 重用测试，应付将来的实现的变化。 提高士气，明确知道我的东西是没问题的。 测试用例是不是用来证明你是对的，而是用来证明你没有错 JUnit4 HelloWorld new project 建立类 建立testcase 放弃旧的断言,使用hamcrest断言 assertThat 使用hamcrest的匹配方法–更自然 示例a. 12345assertThat( n, allOf( greaterThan(1), lessThan(15) ) );assertThat( n, anyOf( greaterThan(16), lessThan(8) ) );assertThat( n, anything() );assertThat( str, is( &quot;bjsxt&quot; ) );assertThat( str, not( &quot;bjxxt&quot; ) ); b. 123456assertThat( str, containsString( &quot;bjsxt&quot; ) );assertThat( str, endsWith(&quot;bjsxt&quot; ) ); assertThat( str, startsWith( &quot;bjsxt&quot; ) ); assertThat( n, equalTo( nExpected ) ); assertThat( str, equalToIgnoringCase( &quot;bjsxt&quot; ) ); assertThat( str, equalToIgnoringWhiteSpace( &quot;bjsxt&quot; ) ); c. 12345assertThat( d, closeTo( 3.0, 0.3 ) );assertThat( d, greaterThan(3.0) );assertThat( d, lessThan (10.0) );assertThat( d, greaterThanOrEqualTo (5.0) );assertThat( d, lessThanOrEqualTo (16.0) ); d. 1234assertThat( map, hasEntry( &quot;bjsxt&quot;, &quot;bjsxt&quot; ) );assertThat( iterable, hasItem ( &quot;bjsxt&quot; ) );assertThat( map, hasKey ( &quot;bjsxt&quot; ) );assertThat( map, hasValue ( &quot;bjsxt&quot; ) ); Failure和Error Failure是指测试失败 Error是指测试程序本身出错 JUnit4 Annotation @Test: 测试方法 (expected=XXException.class) (timeout=xxx) @Ignore: 被忽略的测试方法 @Before: 每一个测试方法之前运行 @After: 每一个测试方法之后运行 @BeforeClass: 所有测试开始之前运行 @AfterClass: 所有测试结束之后运行 运行多个测试注意–遵守约定 类放在test包中 类名用XXXTest结尾 方法用testMethod命名 其他框架 TestNG 下面是一些具体的编写测试代码的技巧或较好的实践方法： 不要用TestCase的构造函数初始化Fixture，而要用setUp()和tearDown()方法。 不要依赖或假定测试运行的顺序，因为JUnit利用Vector保存测试方法。所以不同的平台会按不同的顺序从Vector中取出测试方法。 避免编写有副作用的TestCase。例如：如果随后的测试依赖于某些特定的交易数据，就不要提交交易数据。简单的回滚就可以了。 当继承一个测试类时，记得调用父类的setUp()和tearDown()方法。 将测试代码和工作代码放在一起，一边同步编译和更新。（使用Ant中有支持junit的task. ） 测试类和测试方法应该有一致的命名方案。如在工作类名前加上test从而形成测试类名。 确保测试与时间无关，不要依赖使用过期的数据进行测试。导致在随后的维护过程中很难重现测试。 如果你编写的软件面向国际市场，编写测试时要考虑国际化的因素。不要仅用母语的Locale进行测试。 尽可能地利用JUnit提供地assert/fail方法以及异常处理的方法，可以使代码更为简洁。 测试要尽可能地小，执行速度快。 不要硬性规定数据文件的路径。 利用Junit的自动异常处理书写简洁的测试代码事实上在Junit中使用try-catch来捕获异常是没有必要的，Junit会自动捕获异常。那些没有被捕获的异常就被当成错误处理。 充分利用Junit 的assert/fail 方法assertSame()用来测试两个引用是否指向同一个对象assertEquals()用来测试两个对象是否相等. 确保测试代码与时间无关. 使用文档生成器做测试文档。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaCore 1.多态和运行时类别识别]]></title>
    <url>%2Fyinziang%2F2018%2F02%2F28%2FJavaCore-1-polymorphism%2F</url>
    <content type="text"><![CDATA[面向对象三大特性之一的多态 多态是什么 Java中的多态 运行时类别识别 运行时类型识别(RTTI, Run-Time Type Identification) 维护类的相关信息 多态是基于RTTI实现的 RTTI主要功能由Class类实现 Class类 Class类是”类的类”(class of classes) 如果说类是对象的抽象和集合的话，那么Class类就是对类的抽象和集合 多态的原理 每一个Class类的对象代表一个其他的类 当调用对象的getClass() 方法时，就得到对应Class对象的引用 Java中每个对象都有相应的Class类对象，因此随时能通过Class对象知道某个对象”真正”所属的类 无论对引用进行怎样的类型转换，对象本身所对应的Class对象都是同一个 通过某个引用调用方法时，Java总能找到正确的Class类中所定义的方法，并执行该Class类中的代码 由于Class对象的存在，Java不会因为类型的向上转换而迷失 Class类的加载 当Java创建某个类的对象，比如Human类对象时，Java会检查内存中是否有相应的Class对象 如果内存中没有相应的Class对象，那么Java会在.class文件中寻找Human类的定义，并加载Human类的Class对象 在Class对象加载成功后，其他Human对象的创建和相关操作都将参照该Class对象 多态概念 多态：一个对象变量可以指示多种实际类型的现象。 123graph TDA(多态)--&gt;B(重载Overloading)A(多态)--&gt;C(重写Overriding) 三个必要条件 要有继承 要有重写 父类引用指向子类对象 Java语言中对象变量是多态的。如一个Employee变量既可以引用一个Employee类对象，也可以引用Employee类的任何一个子类的对象（Manager、Secretary、Programmer和Executive[单继承，通过Manager传递，Manager能引用Executive]）。不能将超类的引用赋给子类变量，不是所有的超类(human)都是子类(scientist)。 12345graph TDA(Employee)--&gt;B(Manager)A--&gt;C(Secretary)A--&gt;D(Programmer)B--&gt;E(Executive) 动态绑定在运行时能够自动地选择调用那个方法的现象称为动态绑定（dynamic binding）。 在执行期间（而非编译期间）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。方法储存在代码区(Code Seg)，找到对应方法需要函数指针，而这个指针在new对象的时候被初始化，故可以迟邦定；而且方法的调用可以透过对象变量引用，看到变量的本质类型。 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际类型是D（C的子类），如果D 类定义了该签名（方法的名字和参数列表）就直接调用，否则将在D类的超类中寻找，以此类推（超类的超类）。 动态绑定重要特性：易扩展性。如，假设增加一个新类Executive，并且变量e有可能引用这个类的对象，我们不需要对包含调用e.f()的代码进行重新编译。如果e恰好引用一个Executive类的对象，就会自动地调用Executive.f()方法。 静态绑定如果是方法、方法、方法或者构造器，那么编译器可以准确知道应该调用哪个方法，将这种调用方式成为静态绑定（static binding）。 对象转型(casting) 一个基类的引用类型变量可以“指向”其子类的对象。 一个基类的引用不可以访问其子类对象新增加的成员（属性和方法）。 可以使用用引用变量 instanceof类名来判断该引用型变量所“指向”的对象是否属于该类或该类的子类。 子类的对象可以当作基类的对象来使用称作向上转型(upcasting)，反之称为向下转型(downcasting)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.yza.myJavaBasic;public class ObjectCast &#123; public static void main(String[] args) &#123; Animal a = new Animal("yin"); Dog d = new Dog("yin", "black"); Cat c = new Cat("yin", "black"); System.out.println(a instanceof Animal); System.out.println(d instanceof Animal); System.out.println(c instanceof Animal); System.out.println(a instanceof Dog); a = d; System.out.println(a instanceof Animal); System.out.println(a instanceof Dog); System.out.println(a.getClass()); Dog d1 = (Dog) a; System.out.println(d1.furColor); // dynamic binding Animal animal = new Animal("yin"); System.out.println(animal); animal = d; System.out.println(animal); animal = c; System.out.println(animal); // casting的可扩展性 test(new Animal("yin")); test(d); test(c); // 多态的可扩展性 Lady l1 = new Lady("huang", c); Lady l2 = new Lady("xiong", d); l1.petEnjoy(); l2.petEnjoy(); &#125; public static void test(Animal a) &#123; if(a instanceof Animal) &#123; System.out.println("test " + a); &#125; else if(a instanceof Dog) &#123; Dog dog = (Dog) a; System.out.println("test " + dog + " " + dog.furColor); &#125; else if(a instanceof Cat) &#123; Cat cat = (Cat)a; System.out.println("test " + cat + " " + cat.catColor); &#125; &#125;&#125;class Animal &#123; String name; public Animal(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return name; &#125; public void enjoy() &#123; System.out.println("叫声。。。。。。"); &#125;&#125;class Dog extends Animal &#123; String furColor; public Dog(String name, String color) &#123; super(name); this.furColor = color; &#125; @Override public String toString() &#123; return "Dog " + super.toString() + " " + furColor; &#125; @Override public void enjoy() &#123; System.out.println("狗叫。。。。。。"); &#125;&#125;class Cat extends Animal &#123; String catColor; public Cat(String name, String catColor) &#123; super(name); this.catColor = catColor; &#125; @Override public String toString() &#123; return "Cat " + super.toString() + " " + catColor; &#125; @Override public void enjoy() &#123; System.out.println("猫叫。。。。。。"); &#125;&#125;class Lady &#123; String name; Animal pet; public Lady(String name, Animal animal) &#123; this.name = name; this.pet = animal; &#125; public void petEnjoy() &#123; pet.enjoy(); &#125;&#125; 几种说法 Java语言中对象变量是多态的。如一个Employee变量既可以引用一个Employee类对象，也可以引用Employee类的任何一个子类的对象（Manager、Secretary、Programmer和Executive[单继承，通过Manager传递，Manager能引用Executive]）不能将超类的引用赋给子类变量，不是所有的超类(human)都是子类(scientist)。 将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换（1.只能在继承层次内进行类型转换；2.在将超类转换成子类之前，应该使用instanceOf进行检查）1234if(a instanceof ClassB) &#123; objectB = (ClassB)a; ...&#125;]]></content>
      <categories>
        <category>Java Core</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven本地配置]]></title>
    <url>%2Fyinziang%2F2018%2F02%2F08%2FTools-Intro-Maven%2F</url>
    <content type="text"><![CDATA[Maven基本学习 Maven是什么？为什么使用？ Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的软件项目管理工具 Maven除了以程序构建能力为特色之外，还提供高级项目管理工具。由于Maven的缺省构建规则有较高的可重用性，所以常常用两三行Maven 构建脚本就可以构建简单的项目 Maven的配置 需首先搭建好Java环境 下载JDK 将”JAVA_HOME”变量加入到Windows环境变量中 下载maven 在Apache官网(http://maven.apache.org/download.cgi)下载Maven的bin文件(一般选择最新版本，Windows环境和Mac环境均可下载“apache-maven-版本号-bin.zip”) 在本地特定路径(如”D:\Program Files”)下解压压缩包 本地Maven环境的搭建 右键“计算机”，选择“属性”，之后点击“高级系统设置”，点击“环境变量”，来设置环境变量，有以下系统变量需要配置： 新建系统变量”MAVEN_HOME”，变量值为”D:\Java\apache-maven-3.1.1” 编辑系统变量”Path”，添加变量值”;%MAVEN_HOME%\bin”(Windows 10不需要分号) 检验配置是否成功 键入”win+R”，打开命令行提示符窗口(即Dos界面)，输入”mvn -version” 出现Maven的版本信息即成功 本地配置文件修改 本地仓库 新建一个本地仓库文件夹 在Maven文件夹下找到settings.xml文件，使用编辑器打开 在”“配置上刚刚新建的仓库文件夹路径 download仓库修改成阿里云服务器 国内阿里云仓库123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; IDEA中的maven配置 打开”File-Settings”，点开Maven设置，选择Maven文件夹目录，下拉选择刚刚修改的配置文件(此时会自动检测到修改过的本地仓库路径)]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春招准备]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F28%2FMyPreparation%2F</url>
    <content type="text"><![CDATA[用三周自由时间、三周实训准备春招找实习 方向: Java Web开发工程师 主要需要准备以下内容： Java Core 集合框架的底层实现原理 并发编程相关 Java虚拟机JVM Java Web项目和相关知识 Web项目 数据库 Spring SSM框架Spring 计算机网络 数据结构和算法 年前三周主要目标(按优先级从高到低)： 数据结构和算法 复习王道数据结构和已做笔记 算法题首先结束《剑指Offer》，牛客网上余31道，然后再做结合LeetCode整理 Java Core 学习《Java编程思想》(参考《Java核心技术卷一》) 结合往年考题和牛客网的题库复习 Java虚拟机JVM 主攻《深入理解Java虚拟机》，学习相关概念 结合往年考题 计算机网络的复习 复习王道，做好笔记]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架电商网站实训项目--第二周总结]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F19%2FProjectWeekTwo%2F</url>
    <content type="text"><![CDATA[描述本人本周的工作情况，包括学习内容、项目工作内容和个人任务完成进度主要学习了： JS在前端的一些基础用法 项目工作方面： 讨论具体的需求实现问题 参与小组的项目原型文档的编写 完成商品评论模块需要实现的的类和函数 个人任务完成进度： 电商网站的商品评价功能从数据库到前台展示的编写]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架电商网站实训项目--第一周总结]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F12%2FProjectWeekOne%2F</url>
    <content type="text"><![CDATA[描述本人本周的工作情况，包括学习内容、项目工作内容和个人任务完成进度主要学习了： Spring和MyBatis框架的基本知识、核心配置 SSM框架的整合demo–小型图书管理系统编写 项目工作方面： 帮助确立了小组公共的IDE和版本控制工具 参与需求文档的讨论，了解电商网站的几大模块 思考这些模块该如何实现，准备项目原型文档的编写 个人任务完成进度： 电商网站的开发，正在如火如荼的进行前期知识补强，并且有积极参与小组的需求讨论，特别是需求文档中和自己有关的部分]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis First Demo]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F10%2FMyBatisFirstDemo%2F</url>
    <content type="text"><![CDATA[实践中入门，MyBatis框架小程序 1. 基本学习MyBatis的执行流程·： mybatis配置文件，包括Mybatis全局配置文件和Mybatis映射文件，其中全局配置文件配置了数据源、事务等信息；映射文件配置了SQL执行相关的信息 mybatis通过读取配置文件信息（全局配置文件和映射文件），构造出SqlSessionFactory，即会话工厂 通过SqlSessionFactory，可以创建SqlSession(即会话,Mybatis是通过SqlSession来操作数据库的) SqlSession本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。Executor接口有两个实现类，一个是普通执行器，一个是缓存执行器（默认） Executor执行器要处理的SQL信息是封装到一个底层对象MappedStatement中。该对象包括：SQL语句、输入参数映射信息、输出结果集映射信息。其中输入参数和输出结果的映射类型包括java的简单类型、HashMap集合对象、POJO对象类型 2. 环境配置IDEA Maven项目数据库环境: MySQLMyBatisMaven三维坐标123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; 3. demo编写测试代码123456789101112131415public class UserDaoImpl implements UserDao1 &#123; // 此处选用namespace为&quot;user&quot;，选用此处方法需将UserMapper.xml文件中namespace改过来 public User findUserById(int id) throws Exception &#123; String resource = &quot;mybatis-config1.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = factory.openSession(); //--------------- User user = session.selectOne(&quot;user.findUserById&quot;,id); //参数一：namespace.id //-------------- session.close(); return user; &#125;&#125; Mapper映射配置文件123456789101112131415161718&lt;!--&lt;mapper namespace=&quot;user&quot;&gt;--&gt;&lt;mapper namespace=&quot;user&quot;&gt; &lt;select id=&quot;findAllUsers&quot; resultType=&quot;com.yza.demo1.entity.User&quot;&gt; SELECT * FROM USER &lt;/select&gt; &lt;select id=&quot;insertUser&quot; parameterType=&quot;com.yza.demo1.entity.User&quot;&gt; INSERT INTO USER(id,userName,password,age) VALUES(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;,#&#123;age&#125;) &lt;/select&gt; &lt;select id=&quot;deleteUserById&quot; parameterType=&quot;int&quot; &gt; DELETE FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;updateUserPassword&quot; parameterType=&quot;com.yza.demo1.entity.User&quot;&gt; UPDATE USER SET password=#&#123;password&#125; WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.yza.demo1.entity.User&quot;&gt; SELECT * FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; Mapper接口12345678public interface UserDao1 &#123; public User findUserById(int id) throws Exception; public List&lt;User&gt; findAllUsers() throws Exception; public void insertUser(User user) throws Exception; public void deleteUserById(int id) throws Exception; public void updateUserPassword(User user) throws Exception;&#125; 4. 升级版–Mapper代理开发模式 Mapper代理的开发方式，程序员只需要编写mapper接口（相当于dao接口），不需再编写dao实现类（Mybatis会自动的为mapper接口生成动态代理实现类） 要实现mapper代理的开发方式，需要遵循一些开发规范（接口的包名，类名，参数，返回值分别对应着映射文件的namespace，id，parameterType，resultType） mapper接口的全限定名要和mapper映射文件的namespace的值相同 mapper接口的方法名称要和mapper映射文件中的statement的id相同 mapper接口的方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致 mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致 UserMapper映射文件1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- mapper标签要指定namespace属性，设置为Mapper接口的全路径名--&gt;&lt;mapper namespace=&quot;com.yza.demo1.dao.UserDao&quot;&gt; &lt;select id=&quot;findAllUsers&quot; resultType=&quot;com.yza.demo1.entity.User&quot;&gt; SELECT * FROM USER &lt;/select&gt; &lt;select id=&quot;insertUser&quot; parameterType=&quot;com.yza.demo1.entity.User&quot;&gt; INSERT INTO USER(id,userName,password,age) VALUES(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;,#&#123;age&#125;) &lt;/select&gt; &lt;select id=&quot;deleteUserById&quot; parameterType=&quot;int&quot; &gt; DELETE FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;updateUserPassword&quot; parameterType=&quot;com.yza.demo1.entity.User&quot;&gt; UPDATE USER SET password=#&#123;password&#125; WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.yza.demo1.entity.User&quot;&gt; SELECT * FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; Mapper接口1234567public interface UserMapper &#123; public User findUserById(int id); public List&lt;User&gt; findUserAll(); public void insertUser(User user); public void deleteUserById(int id); public void updateUserPassword(User user);&#125; 报错1报错具体信息12### Error querying database. Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for user.findUserById### Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for user.findUserById 本质原因–mapper文件的namespace和DaoImpl路径不一致mapper文件1234567&lt;!-- mapper标签要指定namespace属性，不然会报错，可看做包名 --&gt;&lt;mapper namespace=&quot;com.yza.demo1.dao.UserDao&quot;&gt;&lt;!--&lt;mapper namespace=&quot;user&quot;&gt;--&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.yza.demo1.entity.User&quot;&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; DaoImpl方法–&gt;此处namespace为”user”1234567891011121314public class UserDaoImpl implements UserDao &#123; public User findUserById(int id) throws Exception &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = factory.openSession(); //--------------- User user = session.selectOne(&quot;user.findUserById&quot;,id); //参数一：namespace.id //-------------- session.close(); return user; &#125;&#125; 总结： namespace：必须与UserDao的全路径想匹配，这样才能使的接口与sql文件一一对应 报错2 使用Java和MyBatis时遇到的数据无法插入问题解决办法–&gt;手动commit session关闭前不会自动提交 手动commit、close，两次导入数据库，报错解决办法：关闭是必须的，就不再提交commit 12345678910public static void main(String[] args) throws Exception &#123; SqlSession sqlSession = SqlSessionFactoryUtil.openSession(); UserDao userDao = sqlSession.getMapper(UserDao.class); User user = new User(3,&quot;yinziyang&quot;,&quot;111111&quot;,22); userDao.insertUser(user); //sqlSession.commit(); sqlSession.close(); &#125; 附录：MyBatisUtil工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.*;import java.io.InputStream;public class SqlSessionFactoryUtil &#123; private static SqlSessionFactory sqlSessionFactory; /** * 初始化sqlSessionFactory */ static &#123; getSqlSessionFactory(); &#125; /** * 获取SqlSessionFactory * @return */ public static SqlSessionFactory getSqlSessionFactory() &#123; if(sqlSessionFactory==null) &#123; InputStream inputStream = null; try &#123; inputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; return sqlSessionFactory; &#125; /** * 获取SqlSession * @return */ public static SqlSession openSession() &#123; return sqlSessionFactory.openSession(); &#125; /** * 关闭SqlSession * @param sqlSession */ public static void clSSoseSession(SqlSession sqlSession) &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 参考 MyBatis学习（1）：Mybatis使用详解和入门案例]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Work Report]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F09%2Fworkreport%2F</url>
    <content type="text"><![CDATA[小结截止到2018年1月9日，约两周的自学小结。 研一上学期的课程学习告一段落已经两个星期了。也算是自己摸索着准备春季实习招聘两周了 起初的计划是先准备一个项目，同时准备算法等基本功，同道小新又指导我搭建了个人博客，就计划着三驾马车并行 慢慢发现： 博客的整理比较花功夫，而且比较零散，牵一发而动全身，可以考虑周末抽出整块时间来做，平时还是以项目为主 算法的整理可以考虑先做，先纸质版打印出来练着，等练习充分了再抽空分块整理 项目的准备，现在处在学习阶段，各方面还不成熟，可以考虑其每天所花时间不超过50% 然后找已经拿到大厂offer的前辈，取经如下： 重视基础，项目次要 实习面试时项目经验缺乏，基础补充 常问自己，LeetCode、剑指Offer刷了吗？虚拟机看了吗？等等等等 定个小目标，年前 完成上述两个题库的常考题型，然后整理一遍 基本掌握SpringMVC、Spring、MyBatis框架项目，掌握Spring框架 掌握Java Core基本知识并刷题]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Guide]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F08%2FGitGuide%2F</url>
    <content type="text"><![CDATA[Git版本控制关于Git版本控制的一些笔记，以及在windows下的一些常规操作 Note1. 三棵树：工作目录、暂存区域和Git仓库Working Directory &lt;-&gt; Stage(Index) &lt;-&gt; Repository(Head)工作目录：平时存放项目的地方暂存区域：一个文件，存放临时的改动，即将提交到仓库的列表信息Git仓库：最终存放版本数据的位置(HEAD指针指向最新版本) 2. 将每个版本独立保存3. Git管理的文件的三种状态 已修改(modified) 已暂存(staged) 已提交(committed) Git的工作流程一般工作流程 在工作目录中添加、修改文件 将需要进行版本管理的文件放入暂存区域 将暂存区域的文件提交到Git仓库 1.在工作目录中添加、修改文件(自己操作)1234C:\Users\Administrator\Documents\GitHub&gt;cd MyProjectC:\Users\Administrator\Documents\GitHub\MyProject&gt;git initInitialized empty Git repository in C:/Users/Administrator/Documents/GitHub/MyProject/.git/ 2.将需要进行版本管理的文件放入暂存区域(没提示信息即ok)1C:\Users\Administrator\Documents\GitHub\MyProject&gt;git add README.md 3.将暂存区域的文件提交到Git仓库commit命令 双引号内是本次提交的说明 1234C:\Users\Administrator\Documents\GitHub\MyProject&gt;git commit -m &quot;add a readme file&quot;[master (root-commit) cbdab70] add a readme file 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README.md 实战 将工作目录的文件放到Git仓库只需要两步 -git add 文件名 -git commit -m “你干了啥，新版本注释” 查看状态1git status 显示Untracked files，工作目录新添加、修改的文件而未添加到暂存区域或提交到Git仓库 12345678C:\Users\Administrator\Documents\GitHub\MyProject&gt;git add LICENSEC:\Users\Administrator\Documents\GitHub\MyProject&gt;git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSE 回滚1git reset HEAD 可以让最近一次提交到Git仓库的文件回到暂存区域 1git reset HEAD &lt;file&gt; 可以让file文件从Git仓库回到暂存区域 123456789101112131415161718192021222324252627282930313233343536C:\Users\Administrator\Documents\GitHub\MyProject&gt;git reset HEADC:\Users\Administrator\Documents\GitHub\MyProject&gt;git statusOn branch masterUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) LICENSEnothing added to commit but untracked files present (use &quot;git add&quot; to track)C:\Users\Administrator\Documents\GitHub\MyProject&gt;git commit -m &quot;add a LICENSE file&quot;On branch masterUntracked files: LICENSEnothing added to commit but untracked files presentC:\Users\Administrator\Documents\GitHub\MyProject&gt;git add LICENSEC:\Users\Administrator\Documents\GitHub\MyProject&gt;git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSEC:\Users\Administrator\Documents\GitHub\MyProject&gt;git commit -m &quot;add a readme file&quot;[master 9ceaa7a] add a readme file 1 file changed, 19 insertions(+) create mode 100644 LICENSEC:\Users\Administrator\Documents\GitHub\MyProject&gt;git statusOn branch masternothing to commit, working tree clean Note：红色表示在工作目录(?)；绿色表示在暂存区域，等待被提交。是否？你查看了工作目录的status，那么文件就默认到暂存区域了，add就提交到Git仓库了 用提交到Git仓库的文件，覆盖工作目录的文件变化1git checkout -- &lt;file&gt; file，如”modified： LICENSE” 查看历史提交1git log 1234567891011121314151617181920C:\Users\Administrator\Documents\GitHub\MyProject&gt;git logcommit 76b5f782d7443442233ae5e050d3c4c8f71968b7Author: 2011301060014@whu.edu.cn &lt;2011301060014@whu.edu.cn&gt;Date: Thu Nov 9 09:00:45 2017 +0800 change the LICENSE filecommit 9ceaa7aea9f293c1189d3bcaf42f653d102a905bAuthor: 2011301060014@whu.edu.cn &lt;2011301060014@whu.edu.cn&gt;Date: Wed Nov 8 21:39:24 2017 +0800 add a readme filecommit cbdab700463d0b214c6f4bb08cc6bba9d30fac41Author: 2011301060014@whu.edu.cn &lt;2011301060014@whu.edu.cn&gt;Date: Wed Nov 8 20:45:23 2017 +0800 add a readme fileC:\Users\Administrator\Documents\GitHub\MyProject&gt; 回到过去参考”reset&amp;checkout.png” 12345sequenceDiagramWorking Directory-&gt;&gt;Stage: addStage-&gt;&gt;Respository: commitRespository-&gt;&gt;Stage: resetStage-&gt;&gt;Working Directory: checkout 附录 – Windows初次使用Git前的配置在命令行模式里输入以下命令： 12-git config -- global user.name &quot;username&quot;-git config -- global user.email &quot;mail&quot; 然后输入 1git config --list 出现邮箱和用户名即ok]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[New Start]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F07%2FNewStart%2F</url>
    <content type="text"><![CDATA[坑爹之路So Many Bugs !!! 1. 找不到路径已经将java文件夹设为了Source Folder，但是找不到放在根路径下的文件ac.xml，代码中不能以下面的方式访问ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ac.xml&quot;); 解决办法–&gt;将文件放在Resource Folder下“正宗的Maven程序，找东西都去resource下面去找!” 2. 页面跳转 clone的项目Tomcat的路径设置不是默认的”/“。不是Project Structure的路径！ Web项目的路径 主要不是Project Structure Tomcat的路径设置]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
</search>
