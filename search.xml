<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算法&OJ--其他--接水装水问题]]></title>
    <url>%2Fyinziang%2F2018%2F03%2F04%2FAlgo-OJ-Others-2%2F</url>
    <content type="text"><![CDATA[总结LintCode上两类看起来类似的问题 装水问题 接水问题 LintCode-383.装最多水的容器 给定 n 个非负整数 a1, a2, …, an, 每个数代表了坐标中的一个点 (i, ai)。画 n 条垂直线，使得 i 垂直线的两个端点分别为(i, ai)和(i, 0)。找到两条线，使得其与 x 轴共同构成一个容器，以容纳最多水。注意：容器不可倾斜。 暴力遍历 每条线和之前所有线计算 记录最大值 时间复杂度：O(n^2) 示例解法 两个指针分别从数组两端开始向中间遍历(分别找到高度不为零的竖边) 每次计算面积，并记录最大值 将较低高度的指针移动一位 遍历整个数组 时间复杂度：O(n) 就示例解法me的思考 从两端逼近，容器X轴边长单调减小，要使面积增大的话，必须增大宽，所以保留长的竖边 1234567891011121314151617181920212223// 示例AC代码public class Solution &#123; // for any i, the maxium area will be the farthest j that has a[j] &gt; a[i]; public int maxArea(int[] height) &#123; if(height == null || height.length &lt; 2) &#123; return 0; &#125; int max = 0; int left = 0; int right = height.length -1; while(left &lt; right) &#123; max = Math.max( max, (right - left) * Math.min(height[left],height[right])); if(height[left] &lt; height[right])&#123; left++; &#125; else &#123; right--; &#125; &#125; return max; &#125;&#125; LintCode-363.接雨水 系列一 Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining. 注意：此时竖边是有宽度的。 此题本质：某一bar的接水量=min(左边bar最大高度，右边bar最大高度)-bar高 最直接的做法 双数组，一个储存左边bar最大高度，一个储存右边bar最大高度 有点绕的最优解 两个记录最大高度的数组，自最大值出现后就不会被调用了(因为取得是min值) 采用对撞型指针，每次让高度较小的指针移动即可 该指针处接水量即为该方向最大值减去该处bar高 循环直至两指针相遇于最高处 123456789101112131415161718192021222324252627public int trapRainWater(int[] heights) &#123; // 双指针问题 if(heights==null || heights.length&lt;2) &#123; return 0; &#125; int water = 0; int left = 0; int right = heights.length - 1; int lMax = 0; int rMax = 0; while(left &lt; right) &#123; lMax = max(lMax, heights[left]); rMax = max(rMax, heights[right]); if(lMax &lt; rMax) &#123; water += lMax - heights[left]; left++; &#125; else &#123; water += rMax - heights[right]; right--; &#125; &#125; return water;&#125; public int max(int a, int b) &#123; return a&gt;b?a:b;&#125; LintCode-364.接雨水 系列二 Given n x m non-negative integers representing an elevation map 2d where the area of each cell is 1 x 1, compute how much water it is able to trap after raining. emmm 此题感觉难度过大。暂不研究]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法&OJ--其他--背包问题]]></title>
    <url>%2Fyinziang%2F2018%2F03%2F03%2FAlgo-OJ-Others-1%2F</url>
    <content type="text"><![CDATA[总结两类 01背包问题 部分背包问题 01背包问题 往背包中装物品。物品有重量和价值属性。每个物品只有一件且不能分割，在不超过背包容量的同时，如何选取物品，使得背包所装的价值最大（背包可以装不满） 经典的DP动态规划问题 具有最优子结构(在此略去证明过程) 递归求解 每个物品都可以选择放入或不放入，n个物品就需要做n次选择 设f[i][w]表示前i件物品恰放入一个容量为w的背包可获得的最大价值 如果放入第i件物品，则f[i][w] = f[i-1][w-w[i]] + v[i] 如果不放入第i件，则f[i][w] = f[i-1][w] 显然有f[i][w] = max(f[i-1][w-w[i]]+v[i], f[i-1][w]) 结合以下实例来理解：往容量的50的包里装(W,A)分别为以下的物品(10,60)、(20,100)、(30,120) 优化空间 采用一维数组来记录每次的判断结果 最终能完全利用该背包的必然是最大价值(即数组最后一个元素) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455// LintCode-125.背包问题 二/** * 问题描述：给出n个物品的体积A[i]和其价值V[i]，将他们装入一个大小为m的背包，最多能装入的总价值有多大？ * @param m: An integer m denotes the size of a backpack * @param A: Given n items with size A[i] * @param V: Given n items with value V[i] * @return: The maximum value */public int backPackII(int m, int[] A, int[] V) &#123; // 边界情况 if(A==null || V==null || A.length!=V.length || A.length==0 || m&lt;=0) &#123; return -1; &#125; int[] dp = new int[m+1]; int max = 0; for(int i=0; i&lt;A.length; i++) &#123; for(int j=m; j&gt;=A[i]; j--) &#123; if(dp[j-A[i]]+V[i] &gt; dp[j]) &#123; dp[j] = dp[j-A[i]]+V[i]; &#125; if(dp[j] &gt; max) &#123; max = dp[j]; &#125; &#125; &#125; return max;&#125;// 变式// LintCode-92.背包问题/** * 问题描述：在n个物品中挑选若干物品装入背包，最多能装多满？假设背包的大小为m，每个物品的大小为A[i]。(不可切割物品) * @param m: An integer m denotes the size of a backpack * @param A: Given n items with size A[i] * @return: The maximum size */public int backPack(int m, int[] A) &#123; if(A==null || A.length==0 || m&lt;=0) return -1; int n = A.length; int[] dp = new int[m+1]; int max = -1; for(int i=0 ;i&lt;n; i++) &#123; for(int j=m; j&gt;=A[i]; j--) &#123; if(dp[j-A[i]] + A[i] &gt; dp[j]) &#123; dp[j] = dp[j-A[i]] + A[i]; if(dp[j] &gt; max) &#123; max = dp[j]; &#125; &#125; &#125; &#125; return max;&#125; 部分背包问题 问题描述 思路 计算出平均价值重量value/weight 按照value/weight从高到低填充背包 最后剩下的装不下的空间，按照该均值乘以剩余容量 物品 重量 价值 单位重量的价值量 A 10 60 6 B 20 100 5 C 30 120 4 例如有如下问题 背包容量是50，求背包可以装三种物品的最大价值(物品可以被拆分) 由于可以拆分，考虑的是单位重量的价值量 可以轻易求得最优价值是：60+100+4*(50-30)=240 完全背包问题 待整理ing 参考资料 动态规划之详细分析0-1背包问题 0-1背包问题入门 0-1背包问题]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学JUnit]]></title>
    <url>%2Fyinziang%2F2018%2F02%2F28%2FTools-JUnit%2F</url>
    <content type="text"><![CDATA[以JUnit为例，学习单元测试相关知识 JUnit什么是单元测试 写了个类，要给别人用，会不会有bug？怎么办？测试一下。用main方法测试好不好？不好！ 不能一起运行！ 大多数情况下需要人为的观察输出确定是否正确 为什么要进行单元测试 重用测试，应付将来的实现的变化。 提高士气，明确知道我的东西是没问题的。 测试用例是不是用来证明你是对的，而是用来证明你没有错 JUnit4 HelloWorld new project 建立类 建立testcase 放弃旧的断言,使用hamcrest断言 assertThat 使用hamcrest的匹配方法–更自然 示例a. 12345assertThat( n, allOf( greaterThan(1), lessThan(15) ) );assertThat( n, anyOf( greaterThan(16), lessThan(8) ) );assertThat( n, anything() );assertThat( str, is( &quot;bjsxt&quot; ) );assertThat( str, not( &quot;bjxxt&quot; ) ); b. 123456assertThat( str, containsString( &quot;bjsxt&quot; ) );assertThat( str, endsWith(&quot;bjsxt&quot; ) ); assertThat( str, startsWith( &quot;bjsxt&quot; ) ); assertThat( n, equalTo( nExpected ) ); assertThat( str, equalToIgnoringCase( &quot;bjsxt&quot; ) ); assertThat( str, equalToIgnoringWhiteSpace( &quot;bjsxt&quot; ) ); c. 12345assertThat( d, closeTo( 3.0, 0.3 ) );assertThat( d, greaterThan(3.0) );assertThat( d, lessThan (10.0) );assertThat( d, greaterThanOrEqualTo (5.0) );assertThat( d, lessThanOrEqualTo (16.0) ); d. 1234assertThat( map, hasEntry( &quot;bjsxt&quot;, &quot;bjsxt&quot; ) );assertThat( iterable, hasItem ( &quot;bjsxt&quot; ) );assertThat( map, hasKey ( &quot;bjsxt&quot; ) );assertThat( map, hasValue ( &quot;bjsxt&quot; ) ); Failure和Error Failure是指测试失败 Error是指测试程序本身出错 JUnit4 Annotation @Test: 测试方法 (expected=XXException.class) (timeout=xxx) @Ignore: 被忽略的测试方法 @Before: 每一个测试方法之前运行 @After: 每一个测试方法之后运行 @BeforeClass: 所有测试开始之前运行 @AfterClass: 所有测试结束之后运行 运行多个测试注意–遵守约定 类放在test包中 类名用XXXTest结尾 方法用testMethod命名 其他框架 TestNG 下面是一些具体的编写测试代码的技巧或较好的实践方法： 不要用TestCase的构造函数初始化Fixture，而要用setUp()和tearDown()方法。 不要依赖或假定测试运行的顺序，因为JUnit利用Vector保存测试方法。所以不同的平台会按不同的顺序从Vector中取出测试方法。 避免编写有副作用的TestCase。例如：如果随后的测试依赖于某些特定的交易数据，就不要提交交易数据。简单的回滚就可以了。 当继承一个测试类时，记得调用父类的setUp()和tearDown()方法。 将测试代码和工作代码放在一起，一边同步编译和更新。（使用Ant中有支持junit的task. ） 测试类和测试方法应该有一致的命名方案。如在工作类名前加上test从而形成测试类名。 确保测试与时间无关，不要依赖使用过期的数据进行测试。导致在随后的维护过程中很难重现测试。 如果你编写的软件面向国际市场，编写测试时要考虑国际化的因素。不要仅用母语的Locale进行测试。 尽可能地利用JUnit提供地assert/fail方法以及异常处理的方法，可以使代码更为简洁。 测试要尽可能地小，执行速度快。 不要硬性规定数据文件的路径。 利用Junit的自动异常处理书写简洁的测试代码事实上在Junit中使用try-catch来捕获异常是没有必要的，Junit会自动捕获异常。那些没有被捕获的异常就被当成错误处理。 充分利用Junit 的assert/fail 方法assertSame()用来测试两个引用是否指向同一个对象assertEquals()用来测试两个对象是否相等. 确保测试代码与时间无关. 使用文档生成器做测试文档。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaCore 1.多态和运行时类别识别]]></title>
    <url>%2Fyinziang%2F2018%2F02%2F28%2FJavaCore-1-polymorphism%2F</url>
    <content type="text"><![CDATA[面向对象三大特性之一的多态 多态是什么 Java中的多态 运行时类别识别 运行时类型识别(RTTI, Run-Time Type Identification) 维护类的相关信息 多态是基于RTTI实现的 RTTI主要功能由Class类实现 Class类 Class类是”类的类”(class of classes) 如果说类是对象的抽象和集合的话，那么Class类就是对类的抽象和集合 多态的原理 每一个Class类的对象代表一个其他的类 当调用对象的getClass() 方法时，就得到对应Class对象的引用 Java中每个对象都有相应的Class类对象，因此随时能通过Class对象知道某个对象”真正”所属的类 无论对引用进行怎样的类型转换，对象本身所对应的Class对象都是同一个 通过某个引用调用方法时，Java总能找到正确的Class类中所定义的方法，并执行该Class类中的代码 由于Class对象的存在，Java不会因为类型的向上转换而迷失 Class类的加载 当Java创建某个类的对象，比如Human类对象时，Java会检查内存中是否有相应的Class对象 如果内存中没有相应的Class对象，那么Java会在.class文件中寻找Human类的定义，并加载Human类的Class对象 在Class对象加载成功后，其他Human对象的创建和相关操作都将参照该Class对象 多态概念 多态：一个对象变量可以指示多种实际类型的现象。 123graph TDA(多态)--&gt;B(重载Overloading)A(多态)--&gt;C(重写Overriding) 三个必要条件 要有继承 要有重写 父类引用指向子类对象 Java语言中对象变量是多态的。如一个Employee变量既可以引用一个Employee类对象，也可以引用Employee类的任何一个子类的对象（Manager、Secretary、Programmer和Executive[单继承，通过Manager传递，Manager能引用Executive]）。不能将超类的引用赋给子类变量，不是所有的超类(human)都是子类(scientist)。 12345graph TDA(Employee)--&gt;B(Manager)A--&gt;C(Secretary)A--&gt;D(Programmer)B--&gt;E(Executive) 动态绑定在运行时能够自动地选择调用那个方法的现象称为动态绑定（dynamic binding）。 在执行期间（而非编译期间）判断所引用对象的实际类型，根据其实际的类型调用其相应的方法。方法储存在代码区(Code Seg)，找到对应方法需要函数指针，而这个指针在new对象的时候被初始化，故可以迟邦定；而且方法的调用可以透过对象变量引用，看到变量的本质类型。 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个类的方法。假设x的实际类型是D（C的子类），如果D 类定义了该签名（方法的名字和参数列表）就直接调用，否则将在D类的超类中寻找，以此类推（超类的超类）。 动态绑定重要特性：易扩展性。如，假设增加一个新类Executive，并且变量e有可能引用这个类的对象，我们不需要对包含调用e.f()的代码进行重新编译。如果e恰好引用一个Executive类的对象，就会自动地调用Executive.f()方法。 静态绑定如果是方法、方法、方法或者构造器，那么编译器可以准确知道应该调用哪个方法，将这种调用方式成为静态绑定（static binding）。 对象转型(casting) 一个基类的引用类型变量可以“指向”其子类的对象。 一个基类的引用不可以访问其子类对象新增加的成员（属性和方法）。 可以使用用引用变量 instanceof类名来判断该引用型变量所“指向”的对象是否属于该类或该类的子类。 子类的对象可以当作基类的对象来使用称作向上转型(upcasting)，反之称为向下转型(downcasting)。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115package com.yza.myJavaBasic;public class ObjectCast &#123; public static void main(String[] args) &#123; Animal a = new Animal("yin"); Dog d = new Dog("yin", "black"); Cat c = new Cat("yin", "black"); System.out.println(a instanceof Animal); System.out.println(d instanceof Animal); System.out.println(c instanceof Animal); System.out.println(a instanceof Dog); a = d; System.out.println(a instanceof Animal); System.out.println(a instanceof Dog); System.out.println(a.getClass()); Dog d1 = (Dog) a; System.out.println(d1.furColor); // dynamic binding Animal animal = new Animal("yin"); System.out.println(animal); animal = d; System.out.println(animal); animal = c; System.out.println(animal); // casting的可扩展性 test(new Animal("yin")); test(d); test(c); // 多态的可扩展性 Lady l1 = new Lady("huang", c); Lady l2 = new Lady("xiong", d); l1.petEnjoy(); l2.petEnjoy(); &#125; public static void test(Animal a) &#123; if(a instanceof Animal) &#123; System.out.println("test " + a); &#125; else if(a instanceof Dog) &#123; Dog dog = (Dog) a; System.out.println("test " + dog + " " + dog.furColor); &#125; else if(a instanceof Cat) &#123; Cat cat = (Cat)a; System.out.println("test " + cat + " " + cat.catColor); &#125; &#125;&#125;class Animal &#123; String name; public Animal(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return name; &#125; public void enjoy() &#123; System.out.println("叫声。。。。。。"); &#125;&#125;class Dog extends Animal &#123; String furColor; public Dog(String name, String color) &#123; super(name); this.furColor = color; &#125; @Override public String toString() &#123; return "Dog " + super.toString() + " " + furColor; &#125; @Override public void enjoy() &#123; System.out.println("狗叫。。。。。。"); &#125;&#125;class Cat extends Animal &#123; String catColor; public Cat(String name, String catColor) &#123; super(name); this.catColor = catColor; &#125; @Override public String toString() &#123; return "Cat " + super.toString() + " " + catColor; &#125; @Override public void enjoy() &#123; System.out.println("猫叫。。。。。。"); &#125;&#125;class Lady &#123; String name; Animal pet; public Lady(String name, Animal animal) &#123; this.name = name; this.pet = animal; &#125; public void petEnjoy() &#123; pet.enjoy(); &#125;&#125; 几种说法 Java语言中对象变量是多态的。如一个Employee变量既可以引用一个Employee类对象，也可以引用Employee类的任何一个子类的对象（Manager、Secretary、Programmer和Executive[单继承，通过Manager传递，Manager能引用Executive]）不能将超类的引用赋给子类变量，不是所有的超类(human)都是子类(scientist)。 将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换（1.只能在继承层次内进行类型转换；2.在将超类转换成子类之前，应该使用instanceOf进行检查）1234if(a instanceof ClassB) &#123; objectB = (ClassB)a; ...&#125;]]></content>
      <categories>
        <category>Java Core</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[春招准备]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F28%2FMyPreparation%2F</url>
    <content type="text"><![CDATA[用三周自由时间、三周实训准备春招找实习 方向: Java Web开发工程师 主要需要准备以下内容： Java Core 集合框架的底层实现原理 并发编程相关 Java虚拟机JVM Java Web项目和相关知识 Web项目 数据库 Spring SSM框架Spring 计算机网络 数据结构和算法 年前三周主要目标(按优先级从高到低)： 数据结构和算法 复习王道数据结构和已做笔记 算法题首先结束《剑指Offer》，牛客网上余31道，然后再做结合LeetCode整理 Java Core 学习《Java编程思想》(参考《Java核心技术卷一》) 结合往年考题和牛客网的题库复习 Java虚拟机JVM 主攻《深入理解Java虚拟机》，学习相关概念 结合往年考题 计算机网络的复习 复习王道，做好笔记]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架电商网站实训项目--第二周总结]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F19%2FProjectWeekTwo%2F</url>
    <content type="text"><![CDATA[描述本人本周的工作情况，包括学习内容、项目工作内容和个人任务完成进度主要学习了： JS在前端的一些基础用法 项目工作方面： 讨论具体的需求实现问题 参与小组的项目原型文档的编写 完成商品评论模块需要实现的的类和函数 个人任务完成进度： 电商网站的商品评价功能从数据库到前台展示的编写]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架电商网站实训项目--第一周总结]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F12%2FProjectWeekOne%2F</url>
    <content type="text"><![CDATA[描述本人本周的工作情况，包括学习内容、项目工作内容和个人任务完成进度主要学习了： Spring和MyBatis框架的基本知识、核心配置 SSM框架的整合demo–小型图书管理系统编写 项目工作方面： 帮助确立了小组公共的IDE和版本控制工具 参与需求文档的讨论，了解电商网站的几大模块 思考这些模块该如何实现，准备项目原型文档的编写 个人任务完成进度： 电商网站的开发，正在如火如荼的进行前期知识补强，并且有积极参与小组的需求讨论，特别是需求文档中和自己有关的部分]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis First Demo]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F10%2FMyBatisFirstDemo%2F</url>
    <content type="text"><![CDATA[实践中入门，MyBatis框架小程序 1. 基本学习MyBatis的执行流程·： mybatis配置文件，包括Mybatis全局配置文件和Mybatis映射文件，其中全局配置文件配置了数据源、事务等信息；映射文件配置了SQL执行相关的信息 mybatis通过读取配置文件信息（全局配置文件和映射文件），构造出SqlSessionFactory，即会话工厂 通过SqlSessionFactory，可以创建SqlSession(即会话,Mybatis是通过SqlSession来操作数据库的) SqlSession本身不能直接操作数据库，它是通过底层的Executor执行器接口来操作数据库的。Executor接口有两个实现类，一个是普通执行器，一个是缓存执行器（默认） Executor执行器要处理的SQL信息是封装到一个底层对象MappedStatement中。该对象包括：SQL语句、输入参数映射信息、输出结果集映射信息。其中输入参数和输出结果的映射类型包括java的简单类型、HashMap集合对象、POJO对象类型 2. 环境配置IDEA Maven项目数据库环境: MySQLMyBatisMaven三维坐标123456&lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt;&lt;/dependency&gt; 3. demo编写测试代码123456789101112131415public class UserDaoImpl implements UserDao1 &#123; // 此处选用namespace为&quot;user&quot;，选用此处方法需将UserMapper.xml文件中namespace改过来 public User findUserById(int id) throws Exception &#123; String resource = &quot;mybatis-config1.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = factory.openSession(); //--------------- User user = session.selectOne(&quot;user.findUserById&quot;,id); //参数一：namespace.id //-------------- session.close(); return user; &#125;&#125; Mapper映射配置文件123456789101112131415161718&lt;!--&lt;mapper namespace=&quot;user&quot;&gt;--&gt;&lt;mapper namespace=&quot;user&quot;&gt; &lt;select id=&quot;findAllUsers&quot; resultType=&quot;com.yza.demo1.entity.User&quot;&gt; SELECT * FROM USER &lt;/select&gt; &lt;select id=&quot;insertUser&quot; parameterType=&quot;com.yza.demo1.entity.User&quot;&gt; INSERT INTO USER(id,userName,password,age) VALUES(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;,#&#123;age&#125;) &lt;/select&gt; &lt;select id=&quot;deleteUserById&quot; parameterType=&quot;int&quot; &gt; DELETE FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;updateUserPassword&quot; parameterType=&quot;com.yza.demo1.entity.User&quot;&gt; UPDATE USER SET password=#&#123;password&#125; WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.yza.demo1.entity.User&quot;&gt; SELECT * FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; Mapper接口12345678public interface UserDao1 &#123; public User findUserById(int id) throws Exception; public List&lt;User&gt; findAllUsers() throws Exception; public void insertUser(User user) throws Exception; public void deleteUserById(int id) throws Exception; public void updateUserPassword(User user) throws Exception;&#125; 4. 升级版–Mapper代理开发模式 Mapper代理的开发方式，程序员只需要编写mapper接口（相当于dao接口），不需再编写dao实现类（Mybatis会自动的为mapper接口生成动态代理实现类） 要实现mapper代理的开发方式，需要遵循一些开发规范（接口的包名，类名，参数，返回值分别对应着映射文件的namespace，id，parameterType，resultType） mapper接口的全限定名要和mapper映射文件的namespace的值相同 mapper接口的方法名称要和mapper映射文件中的statement的id相同 mapper接口的方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致 mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致 UserMapper映射文件1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapperPUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- mapper标签要指定namespace属性，设置为Mapper接口的全路径名--&gt;&lt;mapper namespace=&quot;com.yza.demo1.dao.UserDao&quot;&gt; &lt;select id=&quot;findAllUsers&quot; resultType=&quot;com.yza.demo1.entity.User&quot;&gt; SELECT * FROM USER &lt;/select&gt; &lt;select id=&quot;insertUser&quot; parameterType=&quot;com.yza.demo1.entity.User&quot;&gt; INSERT INTO USER(id,userName,password,age) VALUES(#&#123;id&#125;,#&#123;userName&#125;,#&#123;password&#125;,#&#123;age&#125;) &lt;/select&gt; &lt;select id=&quot;deleteUserById&quot; parameterType=&quot;int&quot; &gt; DELETE FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;updateUserPassword&quot; parameterType=&quot;com.yza.demo1.entity.User&quot;&gt; UPDATE USER SET password=#&#123;password&#125; WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.yza.demo1.entity.User&quot;&gt; SELECT * FROM USER WHERE id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; Mapper接口1234567public interface UserMapper &#123; public User findUserById(int id); public List&lt;User&gt; findUserAll(); public void insertUser(User user); public void deleteUserById(int id); public void updateUserPassword(User user);&#125; 报错1报错具体信息12### Error querying database. Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for user.findUserById### Cause: java.lang.IllegalArgumentException: Mapped Statements collection does not contain value for user.findUserById 本质原因–mapper文件的namespace和DaoImpl路径不一致mapper文件1234567&lt;!-- mapper标签要指定namespace属性，不然会报错，可看做包名 --&gt;&lt;mapper namespace=&quot;com.yza.demo1.dao.UserDao&quot;&gt;&lt;!--&lt;mapper namespace=&quot;user&quot;&gt;--&gt; &lt;select id=&quot;findUserById&quot; parameterType=&quot;int&quot; resultType=&quot;com.yza.demo1.entity.User&quot;&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; DaoImpl方法–&gt;此处namespace为”user”1234567891011121314public class UserDaoImpl implements UserDao &#123; public User findUserById(int id) throws Exception &#123; String resource = &quot;mybatis-config.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = factory.openSession(); //--------------- User user = session.selectOne(&quot;user.findUserById&quot;,id); //参数一：namespace.id //-------------- session.close(); return user; &#125;&#125; 总结： namespace：必须与UserDao的全路径想匹配，这样才能使的接口与sql文件一一对应 报错2 使用Java和MyBatis时遇到的数据无法插入问题解决办法–&gt;手动commit session关闭前不会自动提交 手动commit、close，两次导入数据库，报错解决办法：关闭是必须的，就不再提交commit 12345678910public static void main(String[] args) throws Exception &#123; SqlSession sqlSession = SqlSessionFactoryUtil.openSession(); UserDao userDao = sqlSession.getMapper(UserDao.class); User user = new User(3,&quot;yinziyang&quot;,&quot;111111&quot;,22); userDao.insertUser(user); //sqlSession.commit(); sqlSession.close(); &#125; 附录：MyBatisUtil工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.*;import java.io.InputStream;public class SqlSessionFactoryUtil &#123; private static SqlSessionFactory sqlSessionFactory; /** * 初始化sqlSessionFactory */ static &#123; getSqlSessionFactory(); &#125; /** * 获取SqlSessionFactory * @return */ public static SqlSessionFactory getSqlSessionFactory() &#123; if(sqlSessionFactory==null) &#123; InputStream inputStream = null; try &#123; inputStream = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; catch(Exception e) &#123; e.printStackTrace(); &#125; &#125; return sqlSessionFactory; &#125; /** * 获取SqlSession * @return */ public static SqlSession openSession() &#123; return sqlSessionFactory.openSession(); &#125; /** * 关闭SqlSession * @param sqlSession */ public static void clSSoseSession(SqlSession sqlSession) &#123; if(sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 参考 MyBatis学习（1）：Mybatis使用详解和入门案例]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Work Report]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F09%2Fworkreport%2F</url>
    <content type="text"><![CDATA[小结截止到2018年1月9日，约两周的自学小结。 研一上学期的课程学习告一段落已经两个星期了。也算是自己摸索着准备春季实习招聘两周了 起初的计划是先准备一个项目，同时准备算法等基本功，同道小新又指导我搭建了个人博客，就计划着三驾马车并行 慢慢发现： 博客的整理比较花功夫，而且比较零散，牵一发而动全身，可以考虑周末抽出整块时间来做，平时还是以项目为主 算法的整理可以考虑先做，先纸质版打印出来练着，等练习充分了再抽空分块整理 项目的准备，现在处在学习阶段，各方面还不成熟，可以考虑其每天所花时间不超过50% 然后找已经拿到大厂offer的前辈，取经如下： 重视基础，项目次要 实习面试时项目经验缺乏，基础补充 常问自己，LeetCode、剑指Offer刷了吗？虚拟机看了吗？等等等等 定个小目标，年前 完成上述两个题库的常考题型，然后整理一遍 基本掌握SpringMVC、Spring、MyBatis框架项目，掌握Spring框架 掌握Java Core基本知识并刷题]]></content>
      <categories>
        <category>Others</category>
      </categories>
      <tags>
        <tag>Study</tag>
        <tag>Work</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git Guide]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F08%2FGitGuide%2F</url>
    <content type="text"><![CDATA[Git版本控制关于Git版本控制的一些笔记，以及在windows下的一些常规操作 Note1. 三棵树：工作目录、暂存区域和Git仓库Working Directory &lt;-&gt; Stage(Index) &lt;-&gt; Repository(Head)工作目录：平时存放项目的地方暂存区域：一个文件，存放临时的改动，即将提交到仓库的列表信息Git仓库：最终存放版本数据的位置(HEAD指针指向最新版本) 2. 将每个版本独立保存3. Git管理的文件的三种状态 已修改(modified) 已暂存(staged) 已提交(committed) Git的工作流程一般工作流程 在工作目录中添加、修改文件 将需要进行版本管理的文件放入暂存区域 将暂存区域的文件提交到Git仓库 1.在工作目录中添加、修改文件(自己操作)1234C:\Users\Administrator\Documents\GitHub&gt;cd MyProjectC:\Users\Administrator\Documents\GitHub\MyProject&gt;git initInitialized empty Git repository in C:/Users/Administrator/Documents/GitHub/MyProject/.git/ 2.将需要进行版本管理的文件放入暂存区域(没提示信息即ok)1C:\Users\Administrator\Documents\GitHub\MyProject&gt;git add README.md 3.将暂存区域的文件提交到Git仓库commit命令 双引号内是本次提交的说明 1234C:\Users\Administrator\Documents\GitHub\MyProject&gt;git commit -m &quot;add a readme file&quot;[master (root-commit) cbdab70] add a readme file 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 README.md 实战 将工作目录的文件放到Git仓库只需要两步 -git add 文件名 -git commit -m “你干了啥，新版本注释” 查看状态1git status 显示Untracked files，工作目录新添加、修改的文件而未添加到暂存区域或提交到Git仓库 12345678C:\Users\Administrator\Documents\GitHub\MyProject&gt;git add LICENSEC:\Users\Administrator\Documents\GitHub\MyProject&gt;git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSE 回滚1git reset HEAD 可以让最近一次提交到Git仓库的文件回到暂存区域 1git reset HEAD &lt;file&gt; 可以让file文件从Git仓库回到暂存区域 123456789101112131415161718192021222324252627282930313233343536C:\Users\Administrator\Documents\GitHub\MyProject&gt;git reset HEADC:\Users\Administrator\Documents\GitHub\MyProject&gt;git statusOn branch masterUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) LICENSEnothing added to commit but untracked files present (use &quot;git add&quot; to track)C:\Users\Administrator\Documents\GitHub\MyProject&gt;git commit -m &quot;add a LICENSE file&quot;On branch masterUntracked files: LICENSEnothing added to commit but untracked files presentC:\Users\Administrator\Documents\GitHub\MyProject&gt;git add LICENSEC:\Users\Administrator\Documents\GitHub\MyProject&gt;git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: LICENSEC:\Users\Administrator\Documents\GitHub\MyProject&gt;git commit -m &quot;add a readme file&quot;[master 9ceaa7a] add a readme file 1 file changed, 19 insertions(+) create mode 100644 LICENSEC:\Users\Administrator\Documents\GitHub\MyProject&gt;git statusOn branch masternothing to commit, working tree clean Note：红色表示在工作目录(?)；绿色表示在暂存区域，等待被提交。是否？你查看了工作目录的status，那么文件就默认到暂存区域了，add就提交到Git仓库了 用提交到Git仓库的文件，覆盖工作目录的文件变化1git checkout -- &lt;file&gt; file，如”modified： LICENSE” 查看历史提交1git log 1234567891011121314151617181920C:\Users\Administrator\Documents\GitHub\MyProject&gt;git logcommit 76b5f782d7443442233ae5e050d3c4c8f71968b7Author: 2011301060014@whu.edu.cn &lt;2011301060014@whu.edu.cn&gt;Date: Thu Nov 9 09:00:45 2017 +0800 change the LICENSE filecommit 9ceaa7aea9f293c1189d3bcaf42f653d102a905bAuthor: 2011301060014@whu.edu.cn &lt;2011301060014@whu.edu.cn&gt;Date: Wed Nov 8 21:39:24 2017 +0800 add a readme filecommit cbdab700463d0b214c6f4bb08cc6bba9d30fac41Author: 2011301060014@whu.edu.cn &lt;2011301060014@whu.edu.cn&gt;Date: Wed Nov 8 20:45:23 2017 +0800 add a readme fileC:\Users\Administrator\Documents\GitHub\MyProject&gt; 回到过去参考”reset&amp;checkout.png” 12345sequenceDiagramWorking Directory-&gt;&gt;Stage: addStage-&gt;&gt;Respository: commitRespository-&gt;&gt;Stage: resetStage-&gt;&gt;Working Directory: checkout 附录 – Windows初次使用Git前的配置在命令行模式里输入以下命令： 12-git config -- global user.name &quot;username&quot;-git config -- global user.email &quot;mail&quot; 然后输入 1git config --list 出现邮箱和用户名即ok]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[New Start]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F07%2FNewStart%2F</url>
    <content type="text"><![CDATA[坑爹之路So Many Bugs !!! 1. 找不到路径已经将java文件夹设为了Source Folder，但是找不到放在根路径下的文件ac.xml，代码中不能以下面的方式访问ApplicationContext context = new ClassPathXmlApplicationContext(&quot;ac.xml&quot;); 解决办法–&gt;将文件放在Resource Folder下“正宗的Maven程序，找东西都去resource下面去找!” 2. 页面跳转 clone的项目Tomcat的路径设置不是默认的”/“。不是Project Structure的路径！ Web项目的路径 主要不是Project Structure Tomcat的路径设置]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fyinziang%2F2018%2F01%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Study</tag>
      </tags>
  </entry>
</search>
